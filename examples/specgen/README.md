# Specification Code Generation Example

This example demonstrates how to use code generation to create **dual-representation specifications** that provide:

1. **Maximum in-memory performance** (native Go functions)
2. **SQL generation** when needed (from generated AST)
3. **DRY principle** (write once as Go function)
4. **Type safety** (compile-time checks)

## Problem

In Python, you can parse lambda functions at runtime using `inspect` and `ast`:

```python
# Python
spec = parse(lambda user: user.age >= 18)

# In-memory: use lambda directly
if spec(user):
    print("Adult")

# SQL: parse lambda AST at runtime
sql = spec.to_sql()  # "age >= $1"
```

**Go doesn't support runtime AST inspection**, so we use code generation instead.

## Solution

### 1. Write specifications as normal Go functions

```go
// user.go
//go:generate specgen -type=User

type User struct {
    Age    int
    Active bool
}

// AdultUserSpec checks if user is adult
//spec:sql
func AdultUserSpec(u User) bool {
    return u.Age >= 18
}
```

### 2. Run code generation

```bash
go generate
```

This creates `user_specs_gen.go`:

```go
// Code generated by specgen. DO NOT EDIT.

func AdultUserSpecAST() spec.Visitable {
    return spec.GreaterThanEqual(
        spec.Field(spec.GlobalScope(), "Age"),
        spec.Value(18),
    )
}

func AdultUserSpecSQL() (string, []any, error) {
    ast := AdultUserSpecAST()
    return infra.CompileToSQL(ast)
}
```

### 3. Use in your code

```go
// In-memory: FAST (direct Go function call)
if AdultUserSpec(user) {
    fmt.Println("Adult user")
}

// SQL: when needed
sql, params, _ := AdultUserSpecSQL()
// SELECT * FROM users WHERE Age >= $1
db.Query("SELECT * FROM users WHERE " + sql, params...)
```

## Performance

| Operation | Python (lambda) | Go (generated) |
|-----------|----------------|----------------|
| In-memory check | Bytecode interpretation | **Native Go function** |
| SQL generation | Runtime AST parse | **Pre-generated AST** |
| Type safety | ❌ Runtime | ✅ **Compile-time** |
| Overhead | Parse lambda each time | **Zero** |

## Supported Features

### Comparison Operators

```go
//spec:sql
func AdultUserSpec(u User) bool {
    return u.Age >= 18  // >=, >, <, <=, ==, !=
}
```

### Logical Operators

```go
//spec:sql
func PremiumUserSpec(u User) bool {
    return u.Age >= 18 && u.Active  // &&, ||, !
}
```

### Arithmetic Operators

```go
//spec:sql
func DiscountedPriceSpec(p Product) bool {
    return p.Price - p.Discount > 100  // +, -, *, /, %
}
```

### Complex Expressions

```go
//spec:sql
func ComplexSpec(u User) bool {
    return u.Age >= 18 && (u.Active || u.Premium) && u.Email != ""
}
```

## Running the Example

```bash
# Generate code
go generate

# Run example
go run .
```

## Output

```
=== In-Memory Filtering (Maximum Performance) ===

Adult users:
  - Alice (age: 30)
  - Charlie (age: 25)

=== SQL Generation (For Database Queries) ===

AdultUserSpec SQL:
  WHERE Age >= $1
  Params: [18]

PremiumUserSpec SQL:
  WHERE Age >= $1 AND Active AND Name != $2
  Params: [18 ]
```

## Advantages

1. **Maximum Performance**: In-memory checks use native Go functions (no reflection, no AST traversal)
2. **Zero Overhead**: SQL AST is pre-generated at compile time
3. **DRY**: Write specification once as Go function
4. **Type Safety**: Compiler checks both in-memory and SQL representations
5. **Clear Intent**: `//spec:sql` comment makes it explicit which functions are specifications
6. **Tooling**: Full IDE support, autocomplete, refactoring

## How It Works

1. **specgen** tool:
   - Parses Go source files using `go/parser`
   - Finds functions marked with `//spec:sql`
   - Analyzes function body AST using `go/ast`
   - Generates corresponding Specification AST builder code

2. **Generated code**:
   - `*AST()` functions return Specification AST nodes
   - `*SQL()` functions compile AST to SQL
   - Original functions remain unchanged for in-memory use

3. **Runtime**:
   - In-memory: Direct function call (fastest possible)
   - SQL: Pre-built AST compilation (no parsing overhead)

## Comparison with Python Lambda Parser

| Feature | Python (runtime) | Go (codegen) |
|---------|-----------------|--------------|
| Parse time | **Runtime** (slow) | **Compile time** (zero overhead) |
| In-memory speed | Bytecode | **Native code** |
| Type checking | Runtime | **Compile time** |
| IDE support | Limited | **Full** |
| Error detection | Runtime | **Compile time** |
| Magic level | High | Low |

## Future Enhancements

- [ ] Support for wildcards (collection filtering)
- [ ] Support for nested field access (e.g., `u.Profile.Age`)
- [ ] Support for method calls
- [ ] Custom operator mappings
- [ ] SQL dialect configuration
