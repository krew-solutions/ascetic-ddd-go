package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// specgen generates AST code from specification predicate functions.
//
// Usage:
//
//	//go:generate go run github.com/krew-solutions/ascetic-ddd-go/cmd/specgen -type=User
//
// This will scan all functions with //spec:sql comment and generate
// corresponding AST builder functions in *_spec_gen.go files.

var (
	typeFlag = flag.String("type", "", "Type name to generate specs for")
)

func main() {
	flag.Parse()

	if *typeFlag == "" {
		log.Fatal("Usage: specgen -type=TypeName")
	}

	// Get the directory from GOFILE env variable (set by go:generate)
	gofile := os.Getenv("GOFILE")
	if gofile == "" {
		// Fallback: use current directory
		gofile = "."
	}

	dir := filepath.Dir(gofile)
	if dir == "" {
		dir = "."
	}

	// Parse Go files in the directory
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(fi os.FileInfo) bool {
		// Skip generated files and test files
		name := fi.Name()
		return !strings.HasSuffix(name, "_test.go") &&
			!strings.HasSuffix(name, "_gen.go") &&
			strings.HasSuffix(name, ".go")
	}, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse directory: %v", err)
	}

	// Find specification functions
	var specs []SpecFunc
	var pkgName string

	for name, pkg := range pkgs {
		pkgName = name
		for _, file := range pkg.Files {
			specs = append(specs, findSpecFunctions(fset, file, *typeFlag)...)
		}
	}

	if len(specs) == 0 {
		log.Printf("No specification functions found for type %s", *typeFlag)
		return
	}

	// Generate output file
	outputPath := filepath.Join(dir, strings.ToLower(*typeFlag)+"_specs_gen.go")
	err = generateCode(outputPath, pkgName, *typeFlag, specs)
	if err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	log.Printf("Generated %s with %d specifications", outputPath, len(specs))
}

// SpecFunc represents a specification function
type SpecFunc struct {
	Name string
	Doc  string
	Body ast.Expr
}

// findSpecFunctions finds all functions with //spec:sql comment
func findSpecFunctions(fset *token.FileSet, file *ast.File, typeName string) []SpecFunc {
	var specs []SpecFunc

	ast.Inspect(file, func(n ast.Node) bool {
		funcDecl, ok := n.(*ast.FuncDecl)
		if !ok {
			return true
		}

		// Check if function has //spec:sql comment
		if funcDecl.Doc == nil {
			return true
		}

		hasSpecComment := false
		for _, comment := range funcDecl.Doc.List {
			if strings.Contains(comment.Text, "spec:sql") {
				hasSpecComment = true
				break
			}
		}

		if !hasSpecComment {
			return true
		}

		// Validate function signature: func(T) bool
		if funcDecl.Type.Params == nil || len(funcDecl.Type.Params.List) != 1 {
			log.Printf("Warning: %s must have exactly one parameter", funcDecl.Name.Name)
			return true
		}

		param := funcDecl.Type.Params.List[0]
		paramType, ok := param.Type.(*ast.Ident)
		if !ok || paramType.Name != typeName {
			return true
		}

		if funcDecl.Type.Results == nil || len(funcDecl.Type.Results.List) != 1 {
			log.Printf("Warning: %s must return bool", funcDecl.Name.Name)
			return true
		}

		// Extract the return expression
		if funcDecl.Body == nil || len(funcDecl.Body.List) == 0 {
			log.Printf("Warning: %s has empty body", funcDecl.Name.Name)
			return true
		}

		// Find return statement
		var returnExpr ast.Expr
		for _, stmt := range funcDecl.Body.List {
			if retStmt, ok := stmt.(*ast.ReturnStmt); ok {
				if len(retStmt.Results) == 1 {
					returnExpr = retStmt.Results[0]
					break
				}
			}
		}

		if returnExpr == nil {
			log.Printf("Warning: %s has no return statement", funcDecl.Name.Name)
			return true
		}

		specs = append(specs, SpecFunc{
			Name: funcDecl.Name.Name,
			Doc:  funcDecl.Doc.Text(),
			Body: returnExpr,
		})

		return true
	})

	return specs
}

// generateCode generates the *_spec_gen.go file
func generateCode(outputPath, pkgName, typeName string, specs []SpecFunc) error {
	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write header
	fmt.Fprintf(f, "// Code generated by specgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(f, "package %s\n\n", pkgName)
	fmt.Fprintf(f, "import (\n")
	fmt.Fprintf(f, "\tspec \"github.com/krew-solutions/ascetic-ddd-go/asceticddd/specification/domain\"\n")
	fmt.Fprintf(f, "\tinfra \"github.com/krew-solutions/ascetic-ddd-go/asceticddd/specification/infrastructure\"\n")
	fmt.Fprintf(f, ")\n\n")

	// Generate AST builder for each spec
	for _, s := range specs {
		visitor := NewSpecGenVisitor(typeName)

		// Generate AST function
		fmt.Fprintf(f, "// %sAST returns AST for %s\n", s.Name, s.Name)
		fmt.Fprintf(f, "func %sAST() spec.Visitable {\n", s.Name)
		fmt.Fprintf(f, "\treturn %s\n", visitor.Visit(s.Body))
		fmt.Fprintf(f, "}\n\n")

		// Generate SQL helper
		fmt.Fprintf(f, "// %sSQL returns SQL for %s\n", s.Name, s.Name)
		fmt.Fprintf(f, "func %sSQL() (string, []any, error) {\n", s.Name)
		fmt.Fprintf(f, "\tast := %sAST()\n", s.Name)
		fmt.Fprintf(f, "\treturn infra.CompileToSQL(ast)\n")
		fmt.Fprintf(f, "}\n\n")
	}

	return nil
}

// SpecGenVisitor converts Go AST expressions to Specification AST builder code.
// Implements the Visitor pattern for go/ast nodes.
type SpecGenVisitor struct {
	// typeName is the main type being processed (e.g., "User", "Order")
	typeName string
	// itemName is the current item variable name in wildcard context (e.g., "item")
	itemName string
	// inWildcard indicates if we're inside a wildcard predicate
	inWildcard bool
}

// NewSpecGenVisitor creates a new visitor for the given type.
func NewSpecGenVisitor(typeName string) *SpecGenVisitor {
	return &SpecGenVisitor{
		typeName:   typeName,
		itemName:   "",
		inWildcard: false,
	}
}

// withWildcardContext returns a new visitor configured for wildcard context.
func (v *SpecGenVisitor) withWildcardContext(itemName string) *SpecGenVisitor {
	return &SpecGenVisitor{
		typeName:   v.typeName,
		itemName:   itemName,
		inWildcard: true,
	}
}

// Visit dispatches to the appropriate visit method based on node type.
func (v *SpecGenVisitor) Visit(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.BinaryExpr:
		return v.VisitBinaryExpr(e)
	case *ast.UnaryExpr:
		return v.VisitUnaryExpr(e)
	case *ast.SelectorExpr:
		return v.VisitSelectorExpr(e)
	case *ast.CallExpr:
		return v.VisitCallExpr(e)
	case *ast.BasicLit:
		return v.VisitBasicLit(e)
	case *ast.Ident:
		return v.VisitIdent(e)
	case *ast.ParenExpr:
		return v.VisitParenExpr(e)
	default:
		return fmt.Sprintf("spec.Value(nil) /* TODO: unsupported expr %T */", expr)
	}
}

// VisitBinaryExpr handles binary expressions (comparisons, logical, arithmetic).
func (v *SpecGenVisitor) VisitBinaryExpr(expr *ast.BinaryExpr) string {
	left := v.Visit(expr.X)
	right := v.Visit(expr.Y)

	switch expr.Op {
	// Comparison
	case token.EQL: // ==
		return fmt.Sprintf("spec.Equal(%s, %s)", left, right)
	case token.NEQ: // !=
		return fmt.Sprintf("spec.NotEqual(%s, %s)", left, right)
	case token.LSS: // <
		return fmt.Sprintf("spec.LessThan(%s, %s)", left, right)
	case token.LEQ: // <=
		return fmt.Sprintf("spec.LessThanEqual(%s, %s)", left, right)
	case token.GTR: // >
		return fmt.Sprintf("spec.GreaterThan(%s, %s)", left, right)
	case token.GEQ: // >=
		return fmt.Sprintf("spec.GreaterThanEqual(%s, %s)", left, right)

	// Logical
	case token.LAND: // &&
		return fmt.Sprintf("spec.And(%s, %s)", left, right)
	case token.LOR: // ||
		return fmt.Sprintf("spec.Or(%s, %s)", left, right)

	// Arithmetic
	case token.ADD: // +
		return fmt.Sprintf("spec.Add(%s, %s)", left, right)
	case token.SUB: // -
		return fmt.Sprintf("spec.Sub(%s, %s)", left, right)
	case token.MUL: // *
		return fmt.Sprintf("spec.Mul(%s, %s)", left, right)
	case token.QUO: // /
		return fmt.Sprintf("spec.Div(%s, %s)", left, right)
	case token.REM: // %
		return fmt.Sprintf("spec.Mod(%s, %s)", left, right)

	// Bitwise
	case token.AND: // & (bitwise AND)
		return fmt.Sprintf("spec.Value(nil) /* TODO: bitwise AND not yet implemented in spec: %s & %s */", left, right)
	case token.OR: // | (bitwise OR)
		return fmt.Sprintf("spec.Value(nil) /* TODO: bitwise OR not yet implemented in spec: %s | %s */", left, right)
	case token.XOR: // ^ (bitwise XOR)
		return fmt.Sprintf("spec.Value(nil) /* TODO: bitwise XOR not yet implemented in spec: %s ^ %s */", left, right)
	case token.SHL: // <<
		return fmt.Sprintf("spec.LeftShift(%s, %s)", left, right)
	case token.SHR: // >>
		return fmt.Sprintf("spec.RightShift(%s, %s)", left, right)

	default:
		return fmt.Sprintf("spec.Value(nil) /* TODO: unsupported op %v */", expr.Op)
	}
}

// VisitUnaryExpr handles unary expressions (!, -, +).
func (v *SpecGenVisitor) VisitUnaryExpr(expr *ast.UnaryExpr) string {
	operand := v.Visit(expr.X)

	switch expr.Op {
	case token.NOT: // !
		return fmt.Sprintf("spec.Not(%s)", operand)
	case token.SUB: // - (negation)
		return fmt.Sprintf("spec.Neg(%s)", operand)
	case token.ADD: // + (positive, no-op)
		return operand
	default:
		return fmt.Sprintf("spec.Value(nil) /* TODO: unsupported unary op %v */", expr.Op)
	}
}

// VisitSelectorExpr handles field access (e.g., u.Age, item.Price, u.Profile.Age).
func (v *SpecGenVisitor) VisitSelectorExpr(expr *ast.SelectorExpr) string {
	// Build the chain of field accesses
	var path []string
	var baseIdent *ast.Ident

	// Walk up the chain to collect all field names
	current := expr
	for {
		path = append([]string{current.Sel.Name}, path...) // prepend

		switch x := current.X.(type) {
		case *ast.SelectorExpr:
			// Nested selector (e.g., u.Profile.Age)
			current = x
			continue
		case *ast.Ident:
			// Base identifier (u, item, etc.)
			baseIdent = x
		default:
			// Unknown base
			return fmt.Sprintf("spec.Value(nil) /* TODO: unsupported selector base %T */", current.X)
		}
		break
	}

	// Determine the scope based on context
	var scope string
	if v.inWildcard && baseIdent.Name == v.itemName {
		// Inside wildcard, referring to item
		scope = "spec.Item()"
	} else {
		// Normal context, referring to root object
		scope = "spec.GlobalScope()"
	}

	// Build nested Object chain for all but the last field
	for i := 0; i < len(path)-1; i++ {
		scope = fmt.Sprintf("spec.Object(%s, %q)", scope, path[i])
	}

	// Last element is the field
	return fmt.Sprintf("spec.Field(%s, %q)", scope, path[len(path)-1])
}

// VisitCallExpr handles function calls (Any, All, IsNull, method calls).
func (v *SpecGenVisitor) VisitCallExpr(expr *ast.CallExpr) string {
	switch fun := expr.Fun.(type) {
	case *ast.Ident:
		switch fun.Name {
		case "Any", "All":
			return v.visitAnyAll(expr, fun.Name)
		}
	case *ast.SelectorExpr:
		switch fun.Sel.Name {
		case "Any", "All":
			return v.visitAnyAll(expr, fun.Sel.Name)
		case "IsNull":
			return v.visitIsNull(expr)
		case "IsNotNull":
			return v.visitIsNotNull(expr)

		// Value Object comparison methods
		case "Equal", "Equals", "Eq":
			return v.visitMethodComparison(expr, fun, "spec.Equal")
		case "NotEqual", "NotEquals", "Ne", "Neq":
			return v.visitMethodComparison(expr, fun, "spec.NotEqual")
		case "LessThan", "Lt":
			return v.visitMethodComparison(expr, fun, "spec.LessThan")
		case "LessThanOrEqual", "LessThanEqual", "Lte", "Le":
			return v.visitMethodComparison(expr, fun, "spec.LessThanEqual")
		case "GreaterThan", "Gt":
			return v.visitMethodComparison(expr, fun, "spec.GreaterThan")
		case "GreaterThanOrEqual", "GreaterThanEqual", "Gte", "Ge":
			return v.visitMethodComparison(expr, fun, "spec.GreaterThanEqual")
		}
	}

	return fmt.Sprintf("spec.Value(nil) /* TODO: unsupported call %T */", expr.Fun)
}

// VisitBasicLit handles literal values (numbers, strings).
func (v *SpecGenVisitor) VisitBasicLit(expr *ast.BasicLit) string {
	return fmt.Sprintf("spec.Value(%s)", expr.Value)
}

// VisitIdent handles identifiers (true, false, nil, field names).
func (v *SpecGenVisitor) VisitIdent(expr *ast.Ident) string {
	// Boolean constants or nil
	if expr.Name == "true" || expr.Name == "false" || expr.Name == "nil" {
		return fmt.Sprintf("spec.Value(%s)", expr.Name)
	}
	// Direct field access (rare, but possible)
	return fmt.Sprintf("spec.Field(spec.GlobalScope(), %q)", expr.Name)
}

// VisitParenExpr handles parenthesized expressions.
func (v *SpecGenVisitor) VisitParenExpr(expr *ast.ParenExpr) string {
	return v.Visit(expr.X)
}

// visitAnyAll handles Any/All collection predicates.
func (v *SpecGenVisitor) visitAnyAll(expr *ast.CallExpr, funcName string) string {
	// Any/All(collection, func(item Type) bool { return predicate })
	if len(expr.Args) != 2 {
		return fmt.Sprintf("spec.Value(nil) /* %s requires 2 arguments */", funcName)
	}

	// First arg is the collection selector (e.g., store.Items or region.Categories)
	collectionExpr := expr.Args[0]
	collectionSelector, ok := collectionExpr.(*ast.SelectorExpr)
	if !ok {
		return fmt.Sprintf("spec.Value(nil) /* %s first arg must be selector */", funcName)
	}

	collectionField := collectionSelector.Sel.Name

	// Build parent scope for collection
	var parentScope string
	switch x := collectionSelector.X.(type) {
	case *ast.Ident:
		// Check if this is item.Collection (nested wildcard) or root.Collection
		if v.inWildcard && x.Name == v.itemName {
			// Nested wildcard: region.Categories, category.Items, etc.
			parentScope = "spec.Item()"
		} else {
			// Root level: store.Items, o.Regions, etc.
			parentScope = "spec.GlobalScope()"
		}
	case *ast.SelectorExpr:
		// Nested case: store.Nested.Items
		parentScope = v.VisitSelectorExpr(x)
		// Convert Field to Object
		parentScope = fmt.Sprintf("spec.Object(%s.Object(), %s.Name())", parentScope, parentScope)
	default:
		return fmt.Sprintf("spec.Value(nil) /* unsupported collection parent %T */", collectionSelector.X)
	}

	// Second arg is the lambda function
	lambdaExpr := expr.Args[1]
	funcLit, ok := lambdaExpr.(*ast.FuncLit)
	if !ok {
		return fmt.Sprintf("spec.Value(nil) /* %s second arg must be func literal */", funcName)
	}

	// Extract lambda parameter name
	if len(funcLit.Type.Params.List) != 1 || len(funcLit.Type.Params.List[0].Names) != 1 {
		return fmt.Sprintf("spec.Value(nil) /* %s lambda must have exactly one param */", funcName)
	}
	lambdaItemName := funcLit.Type.Params.List[0].Names[0].Name

	// Extract lambda body (should be a return statement)
	if len(funcLit.Body.List) != 1 {
		return fmt.Sprintf("spec.Value(nil) /* %s lambda must have exactly one statement */", funcName)
	}
	retStmt, ok := funcLit.Body.List[0].(*ast.ReturnStmt)
	if !ok || len(retStmt.Results) != 1 {
		return fmt.Sprintf("spec.Value(nil) /* %s lambda must have return statement */", funcName)
	}

	// Convert predicate in wildcard context using a new visitor
	wildcardVisitor := v.withWildcardContext(lambdaItemName)
	predicate := wildcardVisitor.Visit(retStmt.Results[0])

	// Generate Wildcard node
	return fmt.Sprintf("spec.Wildcard(spec.Object(%s, %q), %s)", parentScope, collectionField, predicate)
}

// visitIsNull handles value.IsNull() calls.
func (v *SpecGenVisitor) visitIsNull(expr *ast.CallExpr) string {
	sel, ok := expr.Fun.(*ast.SelectorExpr)
	if !ok {
		return "spec.Value(nil) /* IsNull: invalid selector */"
	}

	operand := v.Visit(sel.X)
	return fmt.Sprintf("spec.IsNull(%s)", operand)
}

// visitIsNotNull handles value.IsNotNull() calls.
func (v *SpecGenVisitor) visitIsNotNull(expr *ast.CallExpr) string {
	sel, ok := expr.Fun.(*ast.SelectorExpr)
	if !ok {
		return "spec.Value(nil) /* IsNotNull: invalid selector */"
	}

	operand := v.Visit(sel.X)
	return fmt.Sprintf("spec.IsNotNull(%s)", operand)
}

// visitMethodComparison handles Value Object method calls like receiver.Equal(arg).
func (v *SpecGenVisitor) visitMethodComparison(expr *ast.CallExpr, sel *ast.SelectorExpr, specFunc string) string {
	if len(expr.Args) != 1 {
		return fmt.Sprintf("spec.Value(nil) /* %s requires exactly 1 argument */", sel.Sel.Name)
	}

	// receiver becomes left operand
	left := v.Visit(sel.X)
	// method argument becomes right operand
	right := v.Visit(expr.Args[0])

	return fmt.Sprintf("%s(%s, %s)", specFunc, left, right)
}
