package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// specgen generates AST code from specification predicate functions.
//
// Usage:
//   //go:generate specgen -type=User
//
// This will scan all functions with //spec:sql comment and generate
// corresponding AST builder functions in *_spec_gen.go files.

var (
	typeFlag = flag.String("type", "", "Type name to generate specs for")
)

func main() {
	flag.Parse()

	if *typeFlag == "" {
		log.Fatal("Usage: specgen -type=TypeName")
	}

	// Get the directory from GOFILE env variable (set by go:generate)
	gofile := os.Getenv("GOFILE")
	if gofile == "" {
		// Fallback: use current directory
		gofile = "."
	}

	dir := filepath.Dir(gofile)
	if dir == "" {
		dir = "."
	}

	// Parse Go files in the directory
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(fi os.FileInfo) bool {
		// Skip generated files and test files
		name := fi.Name()
		return !strings.HasSuffix(name, "_test.go") &&
			!strings.HasSuffix(name, "_gen.go") &&
			strings.HasSuffix(name, ".go")
	}, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse directory: %v", err)
	}

	// Find specification functions
	var specs []SpecFunc
	var pkgName string

	for name, pkg := range pkgs {
		pkgName = name
		for _, file := range pkg.Files {
			specs = append(specs, findSpecFunctions(fset, file, *typeFlag)...)
		}
	}

	if len(specs) == 0 {
		log.Printf("No specification functions found for type %s", *typeFlag)
		return
	}

	// Generate output file
	outputPath := filepath.Join(dir, strings.ToLower(*typeFlag)+"_specs_gen.go")
	err = generateCode(outputPath, pkgName, *typeFlag, specs)
	if err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	log.Printf("Generated %s with %d specifications", outputPath, len(specs))
}

// SpecFunc represents a specification function
type SpecFunc struct {
	Name string
	Doc  string
	Body ast.Expr
}

// findSpecFunctions finds all functions with //spec:sql comment
func findSpecFunctions(fset *token.FileSet, file *ast.File, typeName string) []SpecFunc {
	var specs []SpecFunc

	ast.Inspect(file, func(n ast.Node) bool {
		funcDecl, ok := n.(*ast.FuncDecl)
		if !ok {
			return true
		}

		// Check if function has //spec:sql comment
		if funcDecl.Doc == nil {
			return true
		}

		hasSpecComment := false
		for _, comment := range funcDecl.Doc.List {
			if strings.Contains(comment.Text, "spec:sql") {
				hasSpecComment = true
				break
			}
		}

		if !hasSpecComment {
			return true
		}

		// Validate function signature: func(T) bool
		if funcDecl.Type.Params == nil || len(funcDecl.Type.Params.List) != 1 {
			log.Printf("Warning: %s must have exactly one parameter", funcDecl.Name.Name)
			return true
		}

		param := funcDecl.Type.Params.List[0]
		paramType, ok := param.Type.(*ast.Ident)
		if !ok || paramType.Name != typeName {
			return true
		}

		if funcDecl.Type.Results == nil || len(funcDecl.Type.Results.List) != 1 {
			log.Printf("Warning: %s must return bool", funcDecl.Name.Name)
			return true
		}

		// Extract the return expression
		if funcDecl.Body == nil || len(funcDecl.Body.List) == 0 {
			log.Printf("Warning: %s has empty body", funcDecl.Name.Name)
			return true
		}

		// Find return statement
		var returnExpr ast.Expr
		for _, stmt := range funcDecl.Body.List {
			if retStmt, ok := stmt.(*ast.ReturnStmt); ok {
				if len(retStmt.Results) == 1 {
					returnExpr = retStmt.Results[0]
					break
				}
			}
		}

		if returnExpr == nil {
			log.Printf("Warning: %s has no return statement", funcDecl.Name.Name)
			return true
		}

		specs = append(specs, SpecFunc{
			Name: funcDecl.Name.Name,
			Doc:  funcDecl.Doc.Text(),
			Body: returnExpr,
		})

		return true
	})

	return specs
}

// generateCode generates the *_spec_gen.go file
func generateCode(outputPath, pkgName, typeName string, specs []SpecFunc) error {
	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write header
	fmt.Fprintf(f, "// Code generated by specgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(f, "package %s\n\n", pkgName)
	fmt.Fprintf(f, "import (\n")
	fmt.Fprintf(f, "\tspec \"github.com/krew-solutions/ascetic-ddd-go/asceticddd/specification/domain\"\n")
	fmt.Fprintf(f, "\tinfra \"github.com/krew-solutions/ascetic-ddd-go/asceticddd/specification/infrastructure\"\n")
	fmt.Fprintf(f, ")\n\n")

	// Generate AST builder for each spec
	for _, s := range specs {
		// Generate AST function
		fmt.Fprintf(f, "// %sAST returns AST for %s\n", s.Name, s.Name)
		fmt.Fprintf(f, "func %sAST() spec.Visitable {\n", s.Name)
		fmt.Fprintf(f, "\treturn %s\n", convertExprToAST(s.Body, typeName))
		fmt.Fprintf(f, "}\n\n")

		// Generate SQL helper
		fmt.Fprintf(f, "// %sSQL returns SQL for %s\n", s.Name, s.Name)
		fmt.Fprintf(f, "func %sSQL() (string, []any, error) {\n", s.Name)
		fmt.Fprintf(f, "\tast := %sAST()\n", s.Name)
		fmt.Fprintf(f, "\treturn infra.CompileToSQL(ast)\n")
		fmt.Fprintf(f, "}\n\n")
	}

	return nil
}

// convertExprToAST converts Go expression to Specification AST builder code
func convertExprToAST(expr ast.Expr, typeName string) string {
	switch e := expr.(type) {
	case *ast.BinaryExpr:
		return convertBinaryExpr(e, typeName)

	case *ast.UnaryExpr:
		return convertUnaryExpr(e, typeName)

	case *ast.SelectorExpr:
		// e.g., u.Age
		return fmt.Sprintf("spec.Field(spec.GlobalScope(), %q)", e.Sel.Name)

	case *ast.BasicLit:
		// Constant literal
		return fmt.Sprintf("spec.Value(%s)", e.Value)

	case *ast.Ident:
		// Boolean constants or field access
		if e.Name == "true" || e.Name == "false" {
			return fmt.Sprintf("spec.Value(%s)", e.Name)
		}
		// Could be a field of the type
		return fmt.Sprintf("spec.Field(spec.GlobalScope(), %q)", e.Name)

	case *ast.ParenExpr:
		// Unwrap parentheses
		return convertExprToAST(e.X, typeName)

	default:
		return fmt.Sprintf("spec.Value(nil) // TODO: unsupported expr %T", expr)
	}
}

func convertBinaryExpr(expr *ast.BinaryExpr, typeName string) string {
	left := convertExprToAST(expr.X, typeName)
	right := convertExprToAST(expr.Y, typeName)

	switch expr.Op {
	case token.EQL: // ==
		return fmt.Sprintf("spec.Equal(%s, %s)", left, right)
	case token.NEQ: // !=
		return fmt.Sprintf("spec.NotEqual(%s, %s)", left, right)
	case token.LSS: // <
		return fmt.Sprintf("spec.LessThan(%s, %s)", left, right)
	case token.LEQ: // <=
		return fmt.Sprintf("spec.LessThanEqual(%s, %s)", left, right)
	case token.GTR: // >
		return fmt.Sprintf("spec.GreaterThan(%s, %s)", left, right)
	case token.GEQ: // >=
		return fmt.Sprintf("spec.GreaterThanEqual(%s, %s)", left, right)
	case token.LAND: // &&
		return fmt.Sprintf("spec.And(%s, %s)", left, right)
	case token.LOR: // ||
		return fmt.Sprintf("spec.Or(%s, %s)", left, right)
	case token.ADD: // +
		return fmt.Sprintf("spec.Add(%s, %s)", left, right)
	case token.SUB: // -
		return fmt.Sprintf("spec.Sub(%s, %s)", left, right)
	case token.MUL: // *
		return fmt.Sprintf("spec.Mul(%s, %s)", left, right)
	case token.QUO: // /
		return fmt.Sprintf("spec.Div(%s, %s)", left, right)
	case token.REM: // %
		return fmt.Sprintf("spec.Mod(%s, %s)", left, right)
	default:
		return fmt.Sprintf("spec.Value(nil) // TODO: unsupported op %v", expr.Op)
	}
}

func convertUnaryExpr(expr *ast.UnaryExpr, typeName string) string {
	operand := convertExprToAST(expr.X, typeName)

	switch expr.Op {
	case token.NOT: // !
		return fmt.Sprintf("spec.Not(%s)", operand)
	default:
		return fmt.Sprintf("spec.Value(nil) // TODO: unsupported unary op %v", expr.Op)
	}
}
